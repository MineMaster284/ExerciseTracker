package minerofmillions.exerciseviewer.util

import java.awt.Color
import kotlin.math.pow

fun round(x: Double, places: Int): Double = (x * 10.0.pow(places)).toInt() / 10.0.pow(places)

fun toHex(c: Color) = "#%02X%02X%02X".format(c.red, c.green, c.blue)

/**
 * Returns a map containing values from successive accumulation values generated by applying [operation] from left to right
 * to each element and current accumulator value that starts with [initial] value.
 *
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 *
 * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.
 *
 * @sample samples.collections.Collections.Aggregates.scan
 */
fun <K, V, R> Map<K, V>.scanValues(initial: R, operation: (acc: R, Map.Entry<K, V>) -> R): Map<K, R> {
    var current = initial
    return mapValues {
        current = operation(current, it)
        current
    }
}

/**
 * Returns a map containing keys from successive accumulation values generated by applying [operation] from left to right
 * to each element and current accumulator value that starts with [initial] value.
 *
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 *
 * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.
 *
 * @sample samples.collections.Collections.Aggregates.scan
 */
fun <K, V, R> Map<K, V>.scanKeys(initial: R, operation: (acc: R, Map.Entry<K, V>) -> R): Map<R, V> {
    var current = initial
    return mapKeys {
        current = operation(current, it)
        current
    }
}
